!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AIMC_IN	DianaModules/core/Operations.py	/^    AIMC_IN= enum.auto() # 7 bits$/;"	v	class:IdentityType
AIMC_OUT	DianaModules/core/Operations.py	/^    AIMC_OUT= enum.auto() # 6 bits $/;"	v	class:IdentityType
AddTreeHarmoniser	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.addtreeharmoniser.rewriter import AddTreeHarmoniser$/;"	i
AnalogQuantOp	DianaModules/utils/AnalogRequant.py	/^class AnalogQuantOp(torch.autograd.Function):$/;"	c
AnalogRequantizer	DianaModules/utils/AnalogRequant.py	/^class AnalogRequantizer(nn.Module): # div and clip operations $/;"	c
AnalogRequantizer	DianaModules/utils/Editing.py	/^from DianaModules.utils.AnalogRequant import AnalogRequantizer$/;"	i
Any	DianaModules/utils/BaseModules.py	/^from typing import Any, Dict, Union$/;"	i
ApplicationPoint	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.rewriter.applicationpoint import ApplicationPoint$/;"	i
Applier	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.rewriter.applier import Applier$/;"	i
Candidates	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.pattern.nnsequential.factory.candidates import Candidates, NNModuleDescription$/;"	i
Combine	DianaModules/train.py	/^from pyparsing import Combine$/;"	i
ComposedEditor	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.composededitor import ComposedEditor$/;"	i
DCore	DianaModules/HWModel/HWModel.py	/^class DCore :$/;"	c
DIANAConv2d	DianaModules/__init__.py	/^from  DianaModules.core.operations import DIANAConv2d ,DIANAIdentity, DIANALinear, DIANAReLU $/;"	i
DIANAConv2d	DianaModules/core/Operations.py	/^class DIANAConv2d(QConv2d , DianaBaseOperation):$/;"	c
DIANAConv2d	DianaModules/utils/Editing.py	/^from DianaModules.core.operations import DIANAIdentity, DIANALinear, DIANAReLU, IdentityType , DIANAConv2d$/;"	i
DIANAConv2d	layerstests.py	/^from DianaModules.core.operations import DIANAConv2d$/;"	i
DIANAIdentity	DianaModules/__init__.py	/^from  DianaModules.core.operations import DIANAConv2d ,DIANAIdentity, DIANALinear, DIANAReLU $/;"	i
DIANAIdentity	DianaModules/core/Operations.py	/^class DIANAIdentity(QIdentity , DianaBaseOperation): # general purpose identity for harmoniser adds ( Quant operation )$/;"	c
DIANAIdentity	DianaModules/utils/Editing.py	/^from DianaModules.core.operations import DIANAIdentity, DIANALinear, DIANAReLU, IdentityType , DIANAConv2d$/;"	i
DIANAIdentity	HWValidation.py	/^from    DianaModules.core.operations import DQScaleBias, DIANAIdentity$/;"	i
DIANALinear	DianaModules/__init__.py	/^from  DianaModules.core.operations import DIANAConv2d ,DIANAIdentity, DIANALinear, DIANAReLU $/;"	i
DIANALinear	DianaModules/core/Operations.py	/^class DIANALinear(QLinear , DianaBaseOperation): $/;"	c
DIANALinear	DianaModules/utils/Editing.py	/^from DianaModules.core.operations import DIANAIdentity, DIANALinear, DIANAReLU, IdentityType , DIANAConv2d$/;"	i
DIANAReLU	DianaModules/__init__.py	/^from  DianaModules.core.operations import DIANAConv2d ,DIANAIdentity, DIANALinear, DIANAReLU $/;"	i
DIANAReLU	DianaModules/core/Operations.py	/^class DIANAReLU( PACTReLU  , DianaBaseOperation): $/;"	c
DIANAReLU	DianaModules/utils/Editing.py	/^from DianaModules.core.operations import DIANAIdentity, DIANALinear, DIANAReLU, IdentityType , DIANAConv2d$/;"	i
DIGITAL_IN	DianaModules/core/Operations.py	/^    DIGITAL_IN = enum.auto() # 8 bits (digital core)$/;"	v	class:IdentityType
DIGITAL_OUT	DianaModules/core/Operations.py	/^    DIGITAL_OUT = enum.auto() # 8 bits $/;"	v	class:IdentityType
DORYExporter	DianaModules/utils/onnx.py	/^from quantlib.backends.dory.onnxexporter import DORYExporter$/;"	i
DQScaleBias	HWValidation.py	/^from    DianaModules.core.operations import DQScaleBias, DIANAIdentity$/;"	i
DianaAnnotator	DianaModules/utils/onnx.py	/^class DianaAnnotator(ONNXAnnotator) : $/;"	c
DianaAps	DianaModules/utils/Editing.py	/^class DianaAps(ApplicationPoint, _DianaNode):$/;"	c
DianaBaseOperation	DianaModules/core/Operations.py	/^class DianaBaseOperation:   $/;"	c
DianaBaseOperation	DianaModules/utils/BaseModules.py	/^from DianaModules.core.operations import DianaBaseOperation$/;"	i
DianaExporter	DianaModules/utils/BaseModules.py	/^from DianaModules.utils.onnx import DianaExporter$/;"	i
DianaExporter	DianaModules/utils/onnx.py	/^class DianaExporter(DORYExporter) : $/;"	c
DianaF2FConverter	DianaModules/utils/BaseModules.py	/^from .Editing import DianaF2FConverter, DianaF2TConverter$/;"	i
DianaF2FConverter	DianaModules/utils/Editing.py	/^class DianaF2FConverter(ComposedEditor):$/;"	c
DianaF2FInterposer	DianaModules/utils/Editing.py	/^class DianaF2FInterposer(ComposedEditor): #insert quantidentities between $/;"	c
DianaF2FQuantiser	DianaModules/utils/Editing.py	/^class DianaF2FQuantiser(ComposedEditor):$/;"	c
DianaF2TConverter	DianaModules/utils/BaseModules.py	/^from .Editing import DianaF2FConverter, DianaF2TConverter$/;"	i
DianaF2TConverter	DianaModules/utils/Editing.py	/^class DianaF2TConverter(ComposedEditor) : $/;"	c
DianaLinearOpIntegrizer	DianaModules/utils/Editing.py	/^class DianaLinearOpIntegrizer(ComposedEditor):   $/;"	c
DianaLinearOpIntegrizerApplier	DianaModules/utils/Editing.py	/^class DianaLinearOpIntegrizerApplier(NNModuleApplier): $/;"	c
DianaModule	DianaModules/utils/BaseModules.py	/^class DianaModule: # Base class for all diana models  $/;"	c
DianaModules	DianaModules/utils/Editing.py	/^import DianaModules.utils.DigitalRequant as dq$/;"	i
DianaModules	layerstests.py	/^import DianaModules.core.operations as di$/;"	i
DianaModules	layerstests.py	/^import DianaModules.utils.BaseModules as bm$/;"	i
DianaOpQuantApplier	DianaModules/utils/Editing.py	/^class DianaOpQuantApplier(Applier): $/;"	c
DianaOpQuantFinder	DianaModules/utils/Editing.py	/^class DianaOpQuantFinder(Finder):$/;"	c
DianaQuantizerFuser	DianaModules/utils/Editing.py	/^class DianaQuantizerFuser(Rewriter) :$/;"	c
DianaQuantizerFuserApplier	DianaModules/utils/Editing.py	/^class DianaQuantizerFuserApplier(Applier) : $/;"	c
DianaQuantizerFuserFinder	DianaModules/utils/Editing.py	/^class DianaQuantizerFuserFinder(Finder) : $/;"	c
DianaRequantizer	DianaModules/utils/Editing.py	/^class DianaRequantizer(ComposedEditor):$/;"	c
DianaRequantizerApplier	DianaModules/utils/Editing.py	/^class DianaRequantizerApplier(NNModuleApplier): # this will probably have to be rewritten $/;"	c
Dict	DianaModules/train.py	/^from typing import Dict, Union $/;"	i
Dict	DianaModules/utils/BaseModules.py	/^from typing import Any, Dict, Union$/;"	i
DigitalQuantOp	DianaModules/utils/DigitalRequant.py	/^class DigitalQuantOp(torch.autograd.Function):$/;"	c
DigitalRequantizer	DianaModules/utils/DigitalRequant.py	/^class DigitalRequantizer(Requantisation): # div and clip operations # neeed to inhereit from requantisation for tracing and traversal of quantlib $/;"	c
DigitalRequantizer	layerstests.py	/^from DianaModules.utils.DigitalRequant import DigitalRequantizer$/;"	i
Editor	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.editor import Editor$/;"	i
EpsTunnel	DianaModules/utils/Editing.py	/^from quantlib.editing.graphs.nn.epstunnel import EpsTunnel$/;"	i
EpsTunnelConstructSimplifier	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.epstunnels.simplifier.rewriter import EpsTunnelConstructSimplifier$/;"	i
EpsTunnelInserter	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.epstunnels.inserter.rewriter import EpsTunnelInserter$/;"	i
EpsTunnelRemover	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.epstunnels.remover.rewriter import EpsTunnelRemover$/;"	i
F2FCanonicaliser	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.canonicalisation import F2FCanonicaliser$/;"	i
F2TAnnotator	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.annotation import F2TAnnotator$/;"	i
Finder	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.rewriter.finder import Finder$/;"	i
ILSVRC12	layerstests.py	/^from quantlib.editing.editing.tests import ILSVRC12, common $/;"	i
IdentityType	DianaModules/core/Operations.py	/^class IdentityType(enum.Enum):  $/;"	c
IdentityType	DianaModules/utils/Editing.py	/^from DianaModules.core.operations import DIANAIdentity, DIANALinear, DIANAReLU, IdentityType , DIANAConv2d$/;"	i
InputDescription	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.annotation.inputdescription import InputDescription, InputDescriptionSpecType$/;"	i
InputDescriptionSpecType	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.annotation.inputdescription import InputDescription, InputDescriptionSpecType$/;"	i
LinearOpIntegeriserMatcher	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.integerisation.linearopintegeriser.finder import LinearOpIntegeriserMatcher$/;"	i
List	DianaModules/utils/Editing.py	/^from typing import List, OrderedDict, Union$/;"	i
MODULES_WITH_QUANTIZERS	DianaModules/utils/Editing.py	/^MODULES_WITH_QUANTIZERS = [DIANAConv2d , DIANALinear , nn.AvgPool2d , nn.AdaptiveAvgPool2d]$/;"	v
ModuleMapping	DianaModules/__init__.py	/^from quantlib.algorithms.qalgorithms.modulemapping.modulemapping import ModuleMapping$/;"	i
ModuleWiseConverter	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.modulewiseconverter.rewriter import ModuleWiseConverter$/;"	i
ModuleWiseDescriptionSpecType	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.modulewiseconverter.modulewisedescription.modulewisedescription import ModuleWiseDescriptionSpecType$/;"	i
NNMODULE_TO_DIANA	DianaModules/__init__.py	/^NNMODULE_TO_DIANA = ModuleMapping ([$/;"	v
NNModuleApplier	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.applier import NNModuleApplier$/;"	i
NNModuleDescription	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.pattern.nnsequential.factory.candidates import Candidates, NNModuleDescription$/;"	i
NNModulePattern	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.pattern.base.pattern import NNModulePattern$/;"	i
NNModuleRewriter	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.rewriter.rewriter import NNModuleRewriter$/;"	i
NNSequentialPattern	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules import NNSequentialPattern$/;"	i
NameToModule	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.modulewiseconverter.modulewisedescription.nametomodule.nametomodule import NameToModule$/;"	i
NodesMap	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.applicationpoint import NodesMap$/;"	i
ONNXAnnotator	DianaModules/utils/onnx.py	/^from quantlib.backends.base.onnxannotator import ONNXAnnotator$/;"	i
Optional	DianaModules/utils/onnx.py	/^from typing import Optional$/;"	i
OrderedDict	DianaModules/utils/Editing.py	/^from typing import List, OrderedDict, Union$/;"	i
PACTReLU	DianaModules/core/Operations.py	/^from quantlib.algorithms.qalgorithms.qatalgorithms.pact.qactivations import PACTReLU$/;"	i
Param	HWValidation.py	/^from ast import Param$/;"	i
ParamLayer	HWValidation.py	/^class ParamLayer: $/;"	c
Path	DianaModules/utils/BaseModules.py	/^        from pathlib import Path$/;"	i
Path	DianaModules/utils/onnx.py	/^from pathlib import Path$/;"	i
PathGraphMatcher	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.finder.nnsequential import PathGraphMatcher$/;"	i
QConv2d	DianaModules/core/Operations.py	/^from quantlib.algorithms.qmodules.qmodules.qlinears import QConv2d, QLinear $/;"	i
QDescriptionSpecType	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.qdescription.qdescription import QDescriptionSpecType$/;"	i
QGranularitySpecType	DianaModules/core/Operations.py	/^from quantlib.algorithms.qbase import QRangeSpecType, QGranularitySpecType, QHParamsInitStrategySpecType$/;"	i
QHParamsInitStrategySpecType	DianaModules/core/Operations.py	/^from quantlib.algorithms.qbase import QRangeSpecType, QGranularitySpecType, QHParamsInitStrategySpecType$/;"	i
QIdentity	DianaModules/core/Operations.py	/^from quantlib.algorithms.qmodules.qmodules import  QIdentity$/;"	i
QLinear	DianaModules/core/Operations.py	/^from quantlib.algorithms.qmodules.qmodules.qlinears import QConv2d, QLinear $/;"	i
QRangeSpecType	DianaModules/core/Operations.py	/^from quantlib.algorithms.qbase import QRangeSpecType, QGranularitySpecType, QHParamsInitStrategySpecType$/;"	i
QReLU	DianaModules/core/Operations.py	/^from quantlib.algorithms.qmodules.qmodules.qactivations import QReLU$/;"	i
QResnet20	DianaModules/train.py	/^from DianaModules.Models.QResnet20 import QResnet20$/;"	i
QuantLibHarmonisedAddRetracer	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.float2fake.quantisation.addtreeharmoniser.retracer import QuantLibHarmonisedAddRetracer$/;"	i
QuantLibRetracer	DianaModules/utils/BaseModules.py	/^from quantlib.editing.editing.editors.retracers import QuantLibRetracer$/;"	i
QuantLibRetracer	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.retracers import QuantLibRetracer$/;"	i
QuantLibRetracer	layerstests.py	/^from quantlib.editing.editing.editors.retracers import QuantLibRetracer$/;"	i
Requantisation	DianaModules/utils/DigitalRequant.py	/^from quantlib.editing.graphs.nn.requant import Requantisation $/;"	i
RequantiserMatcher	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.integerisation.requantiser.finder import RequantiserMatcher$/;"	i
Rewriter	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.base.rewriter.rewriter import Rewriter$/;"	i
Roles	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.pattern.nnsequential.factory.roles import Roles$/;"	i
SIMDModel	DianaModules/HWModel/HWModel.py	/^class SIMDModel:$/;"	c
SIMDModel	HWValidation.py	/^from DianaModules.HWModel.HWModel import SIMDModel$/;"	i
SIMDValidation	HWValidation.py	/^class SIMDValidation(unittest.TestCase): $/;"	c
SUPPORTED_LINEAR_FPMODULES	DianaModules/utils/Editing.py	/^SUPPORTED_LINEAR_FPMODULES = (nn.Linear , nn.Conv2d) $/;"	v
Tensor	DianaModules/core/Operations.py	/^from torch import Tensor, nn$/;"	i
Tuple	DianaModules/core/Operations.py	/^from typing import Union , Tuple$/;"	i
Union	DianaModules/core/Operations.py	/^from typing import Union , Tuple$/;"	i
Union	DianaModules/train.py	/^from typing import Dict, Union $/;"	i
Union	DianaModules/utils/BaseModules.py	/^from typing import Any, Dict, Union$/;"	i
Union	DianaModules/utils/Editing.py	/^from typing import List, OrderedDict, Union$/;"	i
Union	HWValidation.py	/^from typing  import Union$/;"	i
_DianaNode	DianaModules/utils/Editing.py	/^class _DianaNode:$/;"	c
_EPS_KWARGS	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.integerisation.requantiser import roles , _EPS_KWARGS,admissible_screenplays$/;"	i
_FakeAQuantiser	DianaModules/core/Operations.py	/^from DianaModules.utils._FakeQuantizer import _FakeDQuantiser, _FakeAQuantiser$/;"	i
_FakeAQuantiser	DianaModules/utils/_FakeQuantizer.py	/^class _FakeAQuantiser(torch.autograd.Function):$/;"	c
_FakeDQuantiser	DianaModules/core/Operations.py	/^from DianaModules.utils._FakeQuantizer import _FakeDQuantiser, _FakeAQuantiser$/;"	i
_FakeDQuantiser	DianaModules/utils/_FakeQuantizer.py	/^class _FakeDQuantiser(torch.autograd.Function): # symmetric quantisation $/;"	c
_QActivation	DianaModules/utils/Editing.py	/^from quantlib.algorithms.qmodules.qmodules.qmodules import _QActivation, _QModule$/;"	i
_QModule	DianaModules/core/Operations.py	/^from quantlib.algorithms.qmodules.qmodules.qmodules import _QModule$/;"	i
_QModule	DianaModules/utils/BaseModules.py	/^from quantlib.algorithms.qmodules.qmodules.qmodules import _QModule$/;"	i
_QModule	DianaModules/utils/Editing.py	/^from quantlib.algorithms.qmodules.qmodules.qmodules import _QActivation, _QModule$/;"	i
__call__	DianaModules/utils/BaseModules.py	/^    def __call__(self, *args: Any, **kwds: Any) -> Any:$/;"	m	class:DianaModule	file:
__init__	DianaModules/core/Operations.py	/^    def __init__(self, qrangespec : QRangeSpecType,$/;"	m	class:DIANALinear
__init__	DianaModules/core/Operations.py	/^    def __init__(self,$/;"	m	class:DIANAConv2d
__init__	DianaModules/core/Operations.py	/^    def __init__(self,$/;"	m	class:DIANAIdentity
__init__	DianaModules/utils/AnalogRequant.py	/^    def __init__(self, scale : torch.Tensor , clip : torch) -> None:$/;"	m	class:AnalogRequantizer
__init__	DianaModules/utils/BaseModules.py	/^    def __init__(self,graph_module: fx.graph_module.GraphModule): $/;"	m	class:DianaModule
__init__	DianaModules/utils/DigitalRequant.py	/^    def __init__(self, scale : torch.Tensor , zero : torch.Tensor , n_levels : torch.Tensor) -> None:$/;"	m	class:DigitalRequantizer
__init__	DianaModules/utils/Editing.py	/^    def __init__(self) -> None:$/;"	m	class:DianaOpQuantApplier
__init__	DianaModules/utils/Editing.py	/^    def __init__(self) -> None:$/;"	m	class:DianaQuantizerFuserFinder
__init__	DianaModules/utils/Editing.py	/^    def __init__(self) : $/;"	m	class:DianaF2TConverter
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaF2FInterposer
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaLinearOpIntegrizer
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaOpQuantFinder
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaQuantizerFuser
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaQuantizerFuserApplier
__init__	DianaModules/utils/Editing.py	/^    def __init__(self):$/;"	m	class:DianaRequantizer
__init__	DianaModules/utils/Editing.py	/^    def __init__(self, pattern: NNModulePattern):$/;"	m	class:DianaLinearOpIntegrizerApplier
__init__	DianaModules/utils/Editing.py	/^    def __init__(self, pattern: NNSequentialPattern):$/;"	m	class:DianaRequantizerApplier
__init__	DianaModules/utils/Editing.py	/^    def __init__(self, type:str, node: fx.node.Node) -> None:$/;"	m	class:_DianaNode
__init__	DianaModules/utils/Editing.py	/^    def __init__(self,$/;"	m	class:DianaF2FConverter
__init__	DianaModules/utils/Editing.py	/^    def __init__(self,$/;"	m	class:DianaF2FQuantiser
__init__	DianaModules/utils/onnx.py	/^    def __init__(self):$/;"	m	class:DianaExporter
__init__	layerstests.py	/^    def __init__(self): $/;"	m	class:digital_core_test
_apply	DianaModules/utils/Editing.py	/^    def _apply(self, g: fx.GraphModule, ap: DianaAps, id_: str) -> fx.GraphModule:$/;"	m	class:DianaOpQuantApplier
_apply	DianaModules/utils/Editing.py	/^    def _apply(self, g: fx.GraphModule, ap: DianaAps, id_: str) -> fx.GraphModule:$/;"	m	class:DianaQuantizerFuserApplier
_apply	DianaModules/utils/Editing.py	/^    def _apply(self, g: fx.GraphModule, ap: NodesMap, id_: str) -> fx.GraphModule:$/;"	m	class:DianaLinearOpIntegrizerApplier
_apply	DianaModules/utils/Editing.py	/^    def _apply(self, g: fx.GraphModule, ap: NodesMap, id_: str) -> fx.GraphModule:$/;"	m	class:DianaRequantizerApplier
_bn	DianaModules/HWModel/HWModel.py	/^    def _bn(cls, layer, in_fmap): # batch norm $/;"	m	class:SIMDModel
_call_qop	DianaModules/core/Operations.py	/^    def _call_qop(self, x: torch.Tensor, *args, **kwargs) -> torch.Tensor:$/;"	m	class:DIANAConv2d
_call_qop	DianaModules/core/Operations.py	/^    def _call_qop(self, x: torch.Tensor, *args, **kwargs) -> torch.Tensor:$/;"	m	class:DIANAIdentity
_call_qop	DianaModules/core/Operations.py	/^    def _call_qop(self, x: torch.Tensor, *args, **kwargs) -> torch.Tensor:$/;"	m	class:DIANALinear
_clip	DianaModules/HWModel/HWModel.py	/^    def _clip(cls, in_fmap, bw):  $/;"	m	class:SIMDModel
_quant	DianaModules/HWModel/HWModel.py	/^    def _quant(cls, layer, in_fmap, ds=False): # quantize $/;"	m	class:SIMDModel
_register_qop	DianaModules/core/Operations.py	/^    def _register_qop(self): #used for autograd functions with non-standard backward gradients $/;"	m	class:DIANAConv2d
_register_qop	DianaModules/core/Operations.py	/^    def _register_qop(self): #used for autograd functions with non-standard backward gradients $/;"	m	class:DIANAIdentity
_register_qop	DianaModules/core/Operations.py	/^    def _register_qop(self): #used for autograd functions with non-standard backward gradients $/;"	m	class:DIANALinear
_relu	DianaModules/HWModel/HWModel.py	/^    def _relu(cls, in_fmap): $/;"	m	class:SIMDModel
_rs	DianaModules/HWModel/HWModel.py	/^    def _rs(cls, layer, in_fmap0, in_fmap1): #residual add $/;"	m	class:SIMDModel
abstractmethod	DianaModules/core/Operations.py	/^from abc import abstractmethod$/;"	i
abstractmethod	DianaModules/utils/BaseModules.py	/^from abc import abstractmethod$/;"	i
admissible_screenplays	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.integerisation.requantiser import roles , _EPS_KWARGS,admissible_screenplays$/;"	i
apply	DianaModules/utils/Editing.py	/^    def apply(self,$/;"	m	class:DianaF2TConverter
b	DianaModules/tests/sandbox.py	/^b = torch.Tensor([[1], [1], [1]])$/;"	v
backward	DianaModules/utils/_FakeQuantizer.py	/^    def backward(   ctx, g_in ) : # straight through estimator $/;"	m	class:_FakeAQuantiser
backward	DianaModules/utils/_FakeQuantizer.py	/^    def backward(   ctx, g_in ) : # straight through estimator $/;"	m	class:_FakeDQuantiser
bm	layerstests.py	/^import DianaModules.utils.BaseModules as bm$/;"	i
check	DianaModules/utils/Editing.py	/^from tabnanny import check$/;"	i
check_aps_commutativity	DianaModules/utils/Editing.py	/^    def check_aps_commutativity(self, aps: List[ApplicationPoint]) -> bool:$/;"	m	class:DianaQuantizerFuserFinder
check_aps_commutativity	DianaModules/utils/Editing.py	/^    def check_aps_commutativity(self, aps: List[DianaAps]) -> bool:$/;"	m	class:DianaOpQuantFinder
checker	DianaModules/utils/Editing.py	/^checker =( lambda m: True , ) $/;"	v
clip_scales	DianaModules/utils/BaseModules.py	/^    def clip_scales(self): # Now it's clipping scales to the nearest power of 2 , but for example if the qhinitparamstart is mean std we can check the nearest power of 2 that would contain a distribution range of values that we find acceptable $/;"	m	class:DianaModule
common	layerstests.py	/^from quantlib.editing.editing.tests import ILSVRC12, common $/;"	i
convert	layerstests.py	/^from lib2to3.pytree import convert$/;"	i
converted_graph	layerstests.py	/^converted_graph = bm.DianaModule.fquantize_model8bit(test_modules) $/;"	v
core	layerstests.py	/^import DianaModules.core.operations as di$/;"	i
create_conv	DianaModules/HWModel/HWModel.py	/^    def create_conv(i_layer, layer_node, dory_node, network_dir, input=None, weight=None, batchnorm_params=None):$/;"	m	class:DCore
create_qhparams	DianaModules/core/Operations.py	/^from quantlib.algorithms.qbase.qhparams.qhparams import create_qhparams$/;"	i
create_torch_module	DianaModules/utils/Editing.py	/^    def create_torch_module(qlinear : _QModule): $/;"	m	class:DianaLinearOpIntegrizerApplier
dataclass	HWValidation.py	/^from attr import dataclass $/;"	i
default	DianaModules/core/Operations.py	/^    default = enum.auto() # 8 Bits $/;"	v	class:IdentityType
di	layerstests.py	/^import DianaModules.core.operations as di$/;"	i
di_roles	DianaModules/utils/Editing.py	/^di_roles = Roles([$/;"	v
digital_core_test	layerstests.py	/^class digital_core_test(nn.Module): # problem with conv of first$/;"	c
dq	DianaModules/utils/Editing.py	/^import DianaModules.utils.DigitalRequant as dq$/;"	i
ds	DianaModules/train.py	/^from torchvision import datasets as ds$/;"	i
ds	DianaModules/utils/BaseModules.py	/^from  torch.utils.data import Dataset as ds  $/;"	i
editing	DianaModules/utils/BaseModules.py	/^import quantlib.editing.graphs as qg$/;"	i
editing	layerstests.py	/^import quantlib.editing.graphs as qg$/;"	i
enum	DianaModules/core/Operations.py	/^import enum$/;"	i
export	DianaModules/utils/onnx.py	/^    def export(self, network: nn.Module, input_shape: torch.Size, path: os.PathLike, name: Optional[str] = None, opset_version: int = 10) -> None:$/;"	m	class:DianaExporter
export_model	DianaModules/utils/BaseModules.py	/^    def export_model(self, x : torch.Tensor): # x is an integrised tensor input is needed for validation in dory graph $/;"	m	class:DianaModule
find	DianaModules/utils/Editing.py	/^    def find(self, g: fx.GraphModule) -> List[DianaAps]:$/;"	m	class:DianaOpQuantFinder
find	DianaModules/utils/Editing.py	/^    def find(self, g: fx.GraphModule) -> List[DianaAps]:$/;"	m	class:DianaQuantizerFuserFinder
floor	DianaModules/train.py	/^from math import floor$/;"	i
floor	DianaModules/utils/BaseModules.py	/^from math import log2, floor$/;"	i
forward	DianaModules/utils/AnalogRequant.py	/^    def forward(ctx , x : torch.Tensor, div : torch.Tensor, zero : torch.Tensor , n_levels: torch.Tensor, mul : torch.Tensor, add : torch.Tensor): $/;"	m	class:AnalogQuantOp
forward	DianaModules/utils/AnalogRequant.py	/^    def forward(self , x : torch.Tensor): $/;"	m	class:AnalogRequantizer
forward	DianaModules/utils/BaseModules.py	/^    def forward(self, x : torch.Tensor) : $/;"	m	class:DianaModule
forward	DianaModules/utils/DigitalRequant.py	/^    def forward(ctx , x : torch.Tensor, div : torch.Tensor, zero : torch.Tensor , clip_hi: torch.Tensor): $/;"	m	class:DigitalQuantOp
forward	DianaModules/utils/DigitalRequant.py	/^    def forward(self , x : torch.Tensor) -> torch.Tensor: $/;"	m	class:DigitalRequantizer
forward	DianaModules/utils/_FakeQuantizer.py	/^    def forward(ctx,  x:   torch.Tensor,$/;"	m	class:_FakeAQuantiser
forward	DianaModules/utils/_FakeQuantizer.py	/^    def forward(ctx,  x:   torch.Tensor,$/;"	m	class:_FakeDQuantiser
forward	layerstests.py	/^    def forward(self, x ): $/;"	m	class:digital_core_test
fp	DianaModules/HWModel/HWModel.py	/^    def fp(cls, layer, in_fmap0, in_fmap1=None, ds=False): # forward pass $/;"	m	class:SIMDModel
fp_dbg	DianaModules/HWModel/HWModel.py	/^    def fp_dbg(cls, layer, in_fmap0, in_fmap1=None, ds=False):$/;"	m	class:SIMDModel
fquantize_model8bit	DianaModules/utils/BaseModules.py	/^    def fquantize_model8bit(cls, model: nn.Module): # from_ floating point quantised model $/;"	m	class:DianaModule
fx	DianaModules/utils/BaseModules.py	/^import torch.fx as fx$/;"	i
fx	DianaModules/utils/Editing.py	/^import torch.fx as fx$/;"	i
gamma	DianaModules/train.py	/^from math import gamma$/;"	i
generate_named_patterns	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.pattern.nnsequential.factory.factory import generate_named_patterns$/;"	i
get_bitwidth	DianaModules/core/Operations.py	/^    def get_bitwidth(self): $/;"	m	class:DianaBaseOperation
get_bitwidth	DianaModules/core/Operations.py	/^    def get_bitwidth(self):$/;"	m	class:DIANAIdentity
get_rewriter_class	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.editors.nnmodules.rewriter.factory import get_rewriter_class$/;"	i
getmodule_name	DianaModules/utils/Editing.py	/^        def getmodule_name(module) :$/;"	f	function:DianaOpQuantFinder.find
graph	layerstests.py	/^graph = quantlib_symbolic_trace(root=test_modules)$/;"	v
is_relu_on	DianaModules/core/Operations.py	/^    def is_relu_on(self) : $/;"	m	class:DIANALinear
is_relu_out	DianaModules/core/Operations.py	/^    def is_relu_out(self) : $/;"	m	class:DIANAConv2d
itertools	DianaModules/utils/Editing.py	/^import itertools$/;"	i
log2	DianaModules/utils/BaseModules.py	/^from math import log2, floor$/;"	i
map_scales	DianaModules/core/Operations.py	/^    def map_scales(self, new_bitwidth=8, signed = True , HW_Behaviour=False): $/;"	m	class:DianaBaseOperation
map_scales	DianaModules/core/Operations.py	/^    def map_scales(self, new_bitwidth=8, signed=True, HW_Behaviour=False):$/;"	m	class:DIANAConv2d
map_scales	DianaModules/core/Operations.py	/^    def map_scales(self, new_bitwidth=8, signed=True, HW_Behaviour=False):$/;"	m	class:DIANAIdentity
map_scales	DianaModules/core/Operations.py	/^    def map_scales(self, new_bitwidth=8, signed=True, HW_Behaviour=False):$/;"	m	class:DIANALinear
map_scales	DianaModules/core/Operations.py	/^    def map_scales(self, new_bitwidth=8, signed=True, HW_Behaviour=False):$/;"	m	class:DIANAReLU
map_scales	DianaModules/utils/BaseModules.py	/^    def map_scales(self, new_bitwidth=8, signed = True , HW_Behaviour=False): # before mapping scale and retraining # TODO change from new_bitwdith and signed to list of qrangespecs or an arbitary number of kwqrgs  $/;"	m	class:DianaModule
math	DianaModules/core/Operations.py	/^import math$/;"	i
math	DianaModules/utils/Editing.py	/^import math$/;"	i
math	HWValidation.py	/^import math$/;"	i
modules	DianaModules/utils/BaseModules.py	/^    def modules(self): $/;"	m	class:DianaModule
named_modules	DianaModules/utils/BaseModules.py	/^    def named_modules(self): $/;"	m	class:DianaModule
nn	DianaModules/__init__.py	/^from torch import nn$/;"	i
nn	DianaModules/core/Operations.py	/^from torch import Tensor, nn$/;"	i
nn	DianaModules/tests/sandbox.py	/^from torch import nn$/;"	i
nn	DianaModules/train.py	/^from torch import nn , optim$/;"	i
nn	DianaModules/train.py	/^from torch import nn$/;"	i
nn	DianaModules/utils/AnalogRequant.py	/^from torch import nn $/;"	i
nn	DianaModules/utils/BaseModules.py	/^from torch import nn$/;"	i
nn	DianaModules/utils/DigitalRequant.py	/^from torch import nn$/;"	i
nn	DianaModules/utils/Editing.py	/^from torch import  nn $/;"	i
nn	DianaModules/utils/onnx.py	/^from torch import nn $/;"	i
nn	layerstests.py	/^from torch import nn$/;"	i
node	DianaModules/utils/Editing.py	/^    def node(self): $/;"	m	class:_DianaNode
np	HWValidation.py	/^import numpy as np $/;"	i
numpy	DianaModules/HWModel/HWModel.py	/^import numpy$/;"	i
optim	DianaModules/train.py	/^from torch import nn , optim$/;"	i
optim	DianaModules/utils/BaseModules.py	/^from torch import optim $/;"	i
os	DianaModules/utils/onnx.py	/^import os $/;"	i
plot_metrics	DianaModules/train.py	/^def plot_metrics(metrics : Dict [str , Dict[str, list]]) : $/;"	f
plot_training_metrics	DianaModules/utils/BaseModules.py	/^    def plot_training_metrics(metrics : Dict [str , Dict[str, list]]) : $/;"	m	class:DianaModule
plt	DianaModules/train.py	/^import matplotlib as plt$/;"	i
plt	DianaModules/utils/BaseModules.py	/^import matplotlib as plt $/;"	i
print_params	HWValidation.py	/^    def print_params(self): $/;"	m	class:ParamLayer
qb	DianaModules/utils/BaseModules.py	/^import quantlib.backends as qb $/;"	i
qg	DianaModules/utils/BaseModules.py	/^import quantlib.editing.graphs as qg$/;"	i
qg	layerstests.py	/^import quantlib.editing.graphs as qg$/;"	i
quantization_aware_train	DianaModules/train.py	/^def quantization_aware_train(model , optimizer,train_dataset: ds, validation_dataset: ds , criterion = nn.CrossEntropyLoss() , scheduler: Union[None , optim.lr_scheduler._LRScheduler]=None,  epochs = 1000 , batch_size = 64 ): $/;"	f
quantlib	DianaModules/utils/BaseModules.py	/^import quantlib.backends as qb $/;"	i
quantlib	DianaModules/utils/BaseModules.py	/^import quantlib.editing.graphs as qg$/;"	i
quantlib	layerstests.py	/^import quantlib.editing.graphs as qg$/;"	i
quantlib_symbolic_trace	DianaModules/utils/Editing.py	/^from quantlib.editing.graphs.fx import quantlib_symbolic_trace$/;"	i
quantlib_symbolic_trace	layerstests.py	/^from quantlib.editing.graphs.fx import quantlib_symbolic_trace$/;"	i
redefine_qhparams	DianaModules/core/Operations.py	/^    def redefine_qhparams(self : _QModule, qrangespec:               QRangeSpecType):  $/;"	m	class:DianaBaseOperation
register	DianaModules/__init__.py	/^from quantlib.algorithms.qalgorithms import  register$/;"	i
require	DianaModules/core/Operations.py	/^from numpy import require$/;"	i
resolve_qrangespec	DianaModules/core/Operations.py	/^from quantlib.algorithms.qbase.qrange.qrange import resolve_qrangespec$/;"	i
roles	DianaModules/utils/Editing.py	/^from quantlib.editing.editing.fake2true.integerisation.requantiser import roles , _EPS_KWARGS,admissible_screenplays$/;"	i
rt	DianaModules/utils/onnx.py	/^import onnxruntime as rt $/;"	i
scheduler	DianaModules/train.py	/^from sched import scheduler$/;"	i
setUp	HWValidation.py	/^    def setUp(self):$/;"	m	class:SIMDValidation
set_relu_on	DianaModules/core/Operations.py	/^    def set_relu_on (self) :$/;"	m	class:DIANALinear
set_relu_out	DianaModules/core/Operations.py	/^    def set_relu_out (self) :$/;"	m	class:DIANAConv2d
start_observing	DianaModules/utils/BaseModules.py	/^    def start_observing(self): #before starting training with FP $/;"	m	class:DianaModule
stop_observing	DianaModules/core/Operations.py	/^    def stop_observing(self):$/;"	m	class:DIANAReLU
stop_observing	DianaModules/utils/BaseModules.py	/^    def stop_observing(self): # before starting training with fake quantised network  $/;"	m	class:DianaModule
symbolic	DianaModules/utils/AnalogRequant.py	/^    def symbolic(g: torch._C.Graph, x: torch._C.Value, div :torch._C.Value , zero : torch._C.Value , n_levels: torch.Tensor ,mul :torch._C.Value , add : torch._C.Value) -> torch._C.Value:$/;"	m	class:AnalogQuantOp
symbolic	DianaModules/utils/DigitalRequant.py	/^    def symbolic(g: torch._C.Graph, x: torch._C.Value, div: torch._C.Value, zero: torch._C.Value, clip_hi: torch._C.Value) -> torch._C.Value:$/;"	m	class:DigitalQuantOp
symbolic	DianaModules/utils/_FakeQuantizer.py	/^    def symbolic(g: torch._C.Graph, input: torch._C.Value) -> torch._C.Value:$/;"	m	class:_FakeDQuantiser
te	DianaModules/tests/sandbox.py	/^te = torch.rand(b.shape)$/;"	v
test_bn	HWValidation.py	/^    def test_bn(self) : # test needs to be edited because of output of dqscale bias was edited$/;"	m	class:SIMDValidation
test_fp	HWValidation.py	/^    def test_fp(self): $/;"	m	class:SIMDValidation
test_mat	layerstests.py	/^    test_mat = torch.rand(3,3 , 20 ,20 )*255$/;"	v	class:digital_core_test
test_mat	layerstests.py	/^test_mat = (torch.rand(1,3,20,20)*255).floor()$/;"	v
test_mat	layerstests.py	/^test_mat = torch.rand(3,3 , 20 ,20 )*255$/;"	v
test_modules	layerstests.py	/^test_modules = digital_core_test()$/;"	v
test_quant	HWValidation.py	/^    def test_quant(self):$/;"	m	class:SIMDValidation
torch	DianaModules/core/Operations.py	/^import torch $/;"	i
torch	DianaModules/tests/sandbox.py	/^import torch $/;"	i
torch	DianaModules/train.py	/^import torch$/;"	i
torch	DianaModules/train.py	/^import torch.utils.data as ut$/;"	i
torch	DianaModules/utils/AnalogRequant.py	/^import torch $/;"	i
torch	DianaModules/utils/BaseModules.py	/^import torch $/;"	i
torch	DianaModules/utils/BaseModules.py	/^import torch.fx as fx$/;"	i
torch	DianaModules/utils/BaseModules.py	/^import torch.utils.data as ut $/;"	i
torch	DianaModules/utils/DigitalRequant.py	/^import torch $/;"	i
torch	DianaModules/utils/Editing.py	/^import torch$/;"	i
torch	DianaModules/utils/Editing.py	/^import torch.fx as fx$/;"	i
torch	DianaModules/utils/_FakeQuantizer.py	/^import torch$/;"	i
torch	DianaModules/utils/onnx.py	/^import torch $/;"	i
torch	HWValidation.py	/^import torch$/;"	i
torch	layerstests.py	/^import torch$/;"	i
train	DianaModules/train.py	/^def train(model: nn.Module, optimizer , data_loader : Dict[str, ut.DataLoader ], epochs = 100 , criterion = nn.CrossEntropyLoss() , scheduler: Union[None, optim.lr_scheduler._LRScheduler]=None): $/;"	f
train	DianaModules/utils/BaseModules.py	/^    def train(model: nn.Module, optimizer , data_loader : Dict[str, ut.DataLoader ], epochs = 100 , criterion = nn.CrossEntropyLoss() , scheduler: Union[None, optim.lr_scheduler._LRScheduler]=None): $/;"	m	class:DianaModule
train_dataset	DianaModules/train.py	/^train_dataset = ds.MNIST(root=".\/data\/MNIST\/train" , train = True, download = True, transform=transforms.Compose(transforms.ToTensor(), transforms.Normalize(0.5,)))$/;"	v
train_model	DianaModules/utils/BaseModules.py	/^    def train_model  (self, optimizer,train_dataset: ds, validation_dataset: ds , criterion = nn.CrossEntropyLoss() , scheduler: Union[None , optim.lr_scheduler._LRScheduler]=None,  epochs = 1000 , batch_size = 64 ): $/;"	m	class:DianaModule
transforms	DianaModules/train.py	/^from torchvision import transforms$/;"	i
true_quantize	DianaModules/utils/BaseModules.py	/^    def true_quantize(self): # integrise model $/;"	m	class:DianaModule
type	DianaModules/utils/Editing.py	/^    def type(self): $/;"	m	class:_DianaNode
unittest	HWValidation.py	/^import unittest$/;"	i
ut	DianaModules/train.py	/^import torch.utils.data as ut$/;"	i
ut	DianaModules/utils/BaseModules.py	/^import torch.utils.data as ut $/;"	i
utils	DianaModules/train.py	/^import torch.utils.data as ut$/;"	i
utils	DianaModules/utils/BaseModules.py	/^import torch.utils.data as ut $/;"	i
utils	DianaModules/utils/Editing.py	/^import DianaModules.utils.DigitalRequant as dq$/;"	i
utils	layerstests.py	/^import DianaModules.utils.BaseModules as bm$/;"	i
validation_dataset	DianaModules/train.py	/^validation_dataset = ds.MNIST(root=".\/data\/MNIST\/valid" , train = False, download = True , transform=transforms.Compose(transforms.ToTensor(), transforms.Normalize(0.5,)))$/;"	v
